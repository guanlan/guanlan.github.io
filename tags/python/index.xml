<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on Guanlan Dai</title><link>https://rmmod.com/tags/python/</link><description>Recent content in Python on Guanlan Dai</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 09 Jan 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://rmmod.com/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Rethink in Functional Languages</title><link>https://rmmod.com/posts/rethink-in-functional-languages/</link><pubDate>Wed, 09 Jan 2013 00:00:00 +0000</pubDate><guid>https://rmmod.com/posts/rethink-in-functional-languages/</guid><description>&lt;p>After about 3 months to learn and using Racket (a programming language in Lisp/Scheme family),  I learning lots of concepts of programming. The most important thing in FL(functional languages) is: &lt;strong>&amp;quot;&lt;em>All data are immutable. All functions are pure.&lt;/em>&amp;quot;&lt;/strong>  &lt;/p>
&lt;h2 id="immutable-data"> Immutable Data&lt;/h2>
&lt;p>Immutable data cannot be modified after being created. It has many advantages:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Inherently Thread safety&lt;/strong> Parallel programming is the nightmare of some programers, because different threads simultaneously access the same object can cause unexpected problem, such like a race conditions. The most famous and classical example is &lt;a href="http://en.wikipedia.org/wiki/Race_condition#Example" target="_blank" rel="noopener noreffer ">Bank Account Problem&lt;/a>. Today we get more and more cores in our computers, so the &lt;a href="http://www.infoq.com/news/2008/06/scala-vs-erlang" target="_blank" rel="noopener noreffer ">multi-core crisis&lt;/a> we need to face, some experts believe in the future, we using Scala or Erlang to deal with this crisis.Interesting thing is many &amp;ldquo;next generation&amp;rdquo; language is either the functional or support functional paradigm.&lt;/li>
&lt;li>&lt;strong>Eliminate side-effects&lt;/strong> There are so many reasons. Most important thing is global variables are difficult to understand. For example, if we want understand one functions in the non-trival project,  and we find a variable define in other place, so we will jump to the definition of this variable and other places where modify it, it will cost us more time to figure out what the exactly meaning of this function. So there is the same reason why the code is much easier to understand if we use immutable objects, because the scope of an immutable object is limited as possible. It will make our programming easier and more robust.&lt;/li>
&lt;/ol>
&lt;p>  The programming experts from other languages also know we need use immutable data as more as possible: Joshua Bloch,the author of Effective Java, said, “If an object is immutable, it can be in only one state, and you win big.You never have to worry about what state the object is in, and you can share it freely, with no need for synchronization.” Scott Meyers, Effective C++, Item 3: &lt;a href="http://codeidol.com/cpp/effective-cpp/Accustoming-Yourself-to-C/Item-3-Use-const-whenever-possible/" target="_blank" rel="noopener noreffer ">Use &lt;em>const&lt;/em> whenever possible&lt;/a>. Other languages also use immutable data frequently, such like Python, the number/string/tuple types are immutable data, the String build-in class in Java is immutable too. But immutable data is inconvenient in some situation:&lt;/p></description></item><item><title>How to use Python like Lisp</title><link>https://rmmod.com/posts/how-to-use-python-like-lisp/</link><pubDate>Mon, 19 Nov 2012 00:00:00 +0000</pubDate><guid>https://rmmod.com/posts/how-to-use-python-like-lisp/</guid><description>&lt;p>Lisp has some very effective way to get jobs done, this article give you a direct way to use Python like Lisp.```
cons = lambda el, lst: (el, lst)&lt;/p>
&lt;pre>&lt;code class="">mklist = lambda *args: reduce(lambda lst, el: cons(el, lst), reversed(args), None) &lt;/code>&lt;/pre>
&lt;p>car = lambda lst: lst[0] if lst else lst&lt;/p>
&lt;pre>&lt;code class="">cdr = lambda lst: lst[1] if lst else lst &lt;/code>&lt;/pre>
&lt;p>nth = lambda n, lst: nth(n-1, cdr(lst)) if n ]]&amp;gt; 0 else car(lst)&lt;/p></description></item></channel></rss>